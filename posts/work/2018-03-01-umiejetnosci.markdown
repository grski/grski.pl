Title: Co trzeba umieć, żeby dostać pierwszą pracę? - co ja umiałem
Date: 2018-03-01
Authors: Olaf Górski
Slug: umiejetnosci
Description: Spis tego, co konkretnie umiałem, gdy dostałem się do pierwszej pracy.

Dziś o tym, co konkretnie trzeba umieć, żeby zdobyć pierwszą pracę, albo raczej o tym, co ja umiałem, gdy pracy szukałem. Tytuł chwytliwy, bo w różnych firmach są różne wymagania co do juniorów i w jednej taki gość jak ja jest stażystą a w drugiej już juniorem, różnie to bywa. Niemniej jest to jednak tylko moja perspektywa, nie jakiś absolutny wyznacznik, ale te rzeczy niżej pozwoliły mi zostać junior python devem, więc coś tam może pomogą.

Oprócz tego opiszę też jakieś swoje projekty, które umieściłem w CV.

Czy to, o czym tutaj napiszę, jest konieczne albo faktycznie wystarczające? Nie wiem. Mi na rozmowach wystarczało, ale za dużo ich przecież nie miałem, więc moje doświadczenie jest ograniczone, ale powiedzmy, że na taki jakiś staż się złapać to umiejąc to, co niżej, raczej bez problemu dacie radę.

Wybrany przeze mnie porządek jest raczej losowy, jeśli coś jest moim zdaniem ważne, to wyraźnie to zaznaczam.

# Googlowanie
To pierwsza i chyba najważniejsza umiejętność. W końcu szeroko pojęta informatyka to nauka nie o programowaniu, tylko o… przetwarzaniu informacji. Częścią tego procesu jest wyszukiwanie, analizowanie i wykorzystywanie danej informacji potrzebnej, by rozwiązać jakiś problem, czy wdrożyć coś nowego. Mówiąc krótko – googlowanie. Co przez to konkretnie rozumiem?

Umiejętność zwięzłego przepisywania błędów, szukania informacji na odpowiednich stronach. Najlepiej po angielsku – w tym języku znajdziemy oczywiście najwięcej materiałów.

Chodzi tu też przede wszystkim o to, by w razie przestoju, problemu, czy błędu nie rozłożyć rąk i stanąć, tylko coś robić, szukać pomocy, informacji. O to chodzi. 99% problemów jest już gdzieś rozwiązanych, trzeba tylko poszukać. Jeśli trafiasz na ten pozostały 1%, to jesteś raczej na tak zaawansowanym poziomie, że nie mamy o czym rozmawiać.

# Angielski
To konieczność. Mnogość materiałów dostępnych po angielsku, fakt, że to język międzynarodowy, spopularyzowany i wszechobecny, jasno przemawia za tym, że jest on konieczny każdemu programiście. Zaraz pewnie znajdą się osoby, które stwierdzą, że oni żadnych języków obcych nie znają, a pracują. Spoko, tylko gdzie? Co to za firma? Raczej nie znam szanujących się firm zatrudniających osoby bez chociaż podstawowego angielskiego.

Jak bez niego współpracować z zagranicznymi klientami, współpracownikami, którzy nierzadko również nie są z Polski i po polsku nie mówią? Jak czytać dokumentacje, kod?

Jaki poziom jest potrzebny? Minimalnie taki, by być w stanie przeczytać dokumentację techniczną jakiegoś języka/frameworka. Na początek starczy.

# Algorytmy
Tak, wbrew pozorom je też trzeba znać. Niby to ‘nudna teoria’ i tak dalej, ale… To konieczność.

Co przez to rozumiem, co umiałem ja, już wyjaśniam.

Podstawowe algorytmy:
a) sortowania

1. Insertion Sort – chyba nie muszę tłumaczyć, proste wyszukiwanie po strukturze danych. Podstawa podstaw.
1. Selection Sort – podobnie jak na górze. Bardzo podstawowe, nieefektywne.
1. Bubble sort
1. Merge sort
b) szukania
1. Linear Search – podstawa kompletna
1. Binary Search
To chyba tyle z takich absolutnych podstaw. I teraz uwaga – czy każdy z tych algorytmów znam dokładnie na pamięć, implementowałem po kilka razy i wykorzystywałem własne, zmodyfikowane wersje? Nie. Po prostu wiem jak działają – znam schemat ich pracy, ich wady i zalety, kiedy użyć jakiego. Kiedy nie używać danego algorytmu, złe przypadki i tak dalej. Bo to ważne jest. Czasami diametralnie zmienia prędkość pracy naszego programu.

Jak już przy algorytmach jesteśmy, to warto wspomnieć o czymś takim jak rekursja, która jest z kolei czymś, co trzeba znać by poznać Merge sorta czy Binary search.

Następną rzeczą ważną jest złożoność obliczeniowa, czy też tak zwane big O. O co chodzi? Tak po chłopsku to jest to ilość jakiś tam ‘ruchów’, których nasz program będzie potrzebował do wykonania danej instrukcji dla zestawu danych n-elementowego. Wyróżniamy różne przypadki dla różnych sytuacji – w najlepszym przypadku, w najgorszym i w średnim. Zazwyczaj podaje się najgorszy, bo to pozwala nam stwierdzić, że ‘no cóż, gorzej już nie będzie’.

Czyli mówiąc jeszcze prościej, to liczba kroków potrzebnych do zrobienia czegoś i jak ona rośnie, kiedy tego czegoś jest więcej do zrobienia. Są różne złożoności - log n, n, n*n, ln n, 1 i tak dalej. O szczegółach rozpisywał się nie będę, szkoda czasu. Generalnie im mniejsza ta złożoność, tym program szybszy.

Struktury danych
Tutaj sprawa jest prosta. Struktury danych to rzeczy, które niejednokrotnie mogą nam ułatwić znacząco życie. Tu warto trochę zagłębić się w szczegóły.

Jakie konkretnie te struktury danych kojarzyłem? Już mówię.

1. Array – chyba każdy zna, co?
1. Dictionary – też?
1. LinkedList – większość?
1. Stack
1. Heap
1. Set
1. Queue
1. Trees
1. HashTable
1. Trie
Przy czym te trzy ostatnie to raczej tak ekstra, ponad poziom bym rzekł. Co tutaj warto wiedzieć? Jakie są wady/zalety danej struktury, kiedy jakiej używać. Złożoności obliczeniowe czy też pamięciowe dla nich i podstawowych operacji na nich jak szukania, wstawianie, sortowanie. Podobnie jak przy algorytmach.

Znowu zaznaczam, że sam to praktycznie żadnej z tych struktur danych nie implementowałem – jedynie wiem jak w przybliżeniu działa i wygląda większość z nich. Jedyne co implementowałem sam, to Linked List.

W każdym razie. To serio się przydaje. Uwierzcie.

# Narzędzia
Trzeba umieć operować narzędziami, które są potrzebne do pracy, koniec i kropka. Co to było w moim przypadku?

IDE – PyCharm jak i Vim. Obecnie korzystam praktycznie jedynie z PyCharma no i teraz jeszcze sublime. Wcześniej był to vim z pluginami, ale… przy większym projekcie dla mnie wygodniejszy po prostu jest PyCharm.

Python – co to virtualenv, pip i te sprawy? Po co to, na co?

Virtualbox – ponownie, warto się troszkę przyuczyć, o co chodzi, bo przydatne narzędzia, zwłaszcza gdy pracujemy przy kilku większych projektach, tak samo jak vagrant.

A teraz dorzucę też trochę takich różnych ogólnych pojęć z szeroko rozumianej branży. Czy musicie każde z nich znać i kiedyś korzystać z danego narzędzia i tak dalej? No nie, ale fajnie jest kojarzyć chociaż, daje to takie rozeznanie i kiedy rozmawiamy z innymi ludźmi, może bardziej doświadczonymi, to pewne terminy będą dla nas znajome, chociaż część. Wtedy, zamiast jakiegoś niezrozumiałego żargonu słychać już minimalnie znajomy bełkot :D

VPS – w skrócie virtual private server, taki twój własny kawałek jakiegoś serwera można by powiedzieć

VPN – virtual private network, taka sieć prywatna można rzec

Docker, Vagrant – to pierwsze to tylko nazwe kojarzę, i że to coś z serwerami i deployem appki, a to drugie to już poczytajcie, bo fajne narzędzie

Protokół HTTP, HTTPS, SSL, SSH , IMAP, POP3 (!) - tak tylko pobieżnie który idzie do czego i czym się różnią

IDE – czyli zintegrowane środowisko programistyczne

MVC – model, view, controller – model przetwarzania danych używany w sporej ilości nowoczesnych frameworków

API – appilcation programming interface (!)

Cookie, Session, Cache – ciasteczka, sesja, cache storage

MySql, Postgres, mongodb, oracle, sqlite, sql, nosql, sql injection - (!) bazy danych, konieczność w większości aplikacji

Kody http: 3xx, 4xx, 5xx, ale w praktyce w sumie starczy: 300, 500, 200, 404

AJAX, JS, ecmascript – javascript, te sprawy, wiadomo

Klasa, Metoda, Obiektowość, programowanie obiektowe, funkcyjne, OOP (!!!) Generalnie obiektówka ważna sprawa

CMS – content managment system

DDOS, DOS – takie ataki złych hakerów

VCS – version control system, czy też system kontroli wersji, np. GIT

Devops – czym się tu zajmujemy

DOM – document object model – dla JS’owców konieczność

DRY, KISS, YAGNI (!!) - takie 3 zasady, których warto się trzymać podczas tworzenia kodu

linux, bash – linux to system operacyjny, bash to język skryptowy tak w uproszczeniu

Framework, library – różnice między nimi, czy to to samo?

Unit test, functional test, (!!) - testy jednostkowe i funkcjonalne, o nich niżej

Hash, crypto – co to takiego ten hash, kryptografia – czym to się w ogóle zajmuje.

Machine code, binary, hex – kod maszynowy, binarny, heksowy. Takie różne systemy liczbowe przydatne, bo nimi posługuje się komputer, a nie dziesiętnym.

Production, dev, qa, localhost – produkcja, czyli serwer, na którym stoi rzeczywista strona/appka klienta, dev – środowisko developerskie, lokalne, localhostowe, qa/testing – takie do testowania można rzec, zanim poleci na produkcje, często wędruje tam, chociaż jak to mówią najlepsze testy to tylko na produkcji. Tak serio to nie, nie próbujcie tego w domu.

Segfault – segmentation fault, czyli co się dzieje, jak trochę nie ogarniesz w niskopoziomowym języku, lub rzadziej, w wysokopoziomoowym

Serwer – tam sobie wrzucamy i odpalamy różne appki/strony (w ogromnym uproszczeniu) i one sobie tam żyją

Spaghetti code – po prostu kod, który jest tragiczny

TDD – test driven development, DDD – domain driven development, ot ciekawostka

Firewall - no chyba tłumaczyć nie trzeba

Compiler, linker, interpreter, assembly

Design pattern, the big4

PNG, JPG, GIF, image sprite - formaty plików w dużym uproszczeniu

IP, TCP, PORT, Apache, Nginx

Bootstrap, jQuery, Material Design, gulp

Dużo? W sumie to nie, bo większość ci się powinna obić kiedyś tam o uszy. Ponownie – chodzi o to, żebyś po prostu kojarzył te terminy i wiedział, o co w nich chodzi.

Większość z nich wyjaśniona jest tutaj: https://www.hackterms.com/ a jak tam nie? Google. Albo DuckDuckGo, kto co woli.

# Języki programowania
Dobra, teraz pora o samych językach pogadać.

W moim przypadku jest to Python. Co konkretnie umiałem?

Po pierwsze zacznijmy od znajomości biblioteki standardowej Pythona. Byłem z nią chociaż pobieżnie znajomy. Co to znaczy? A no, że jak chciałem coś posortować, to nie pisałem sam funkcji, tylko cyk sort(), albo sorted(), zależnie od przypadku i już. Chodzi tu po prostu o takie generalne rozeznanie – tu macie w sumie spis: https://docs.python.org/3/library/index.html
Czy wszystko? Absolutnie nie, po prostu coś tam trzeba kojarzyć, nikt nie oczekuje, że znasz to na pamięć.

Na czym się skupić? Podstawowe typy danych, struktury w Pythonie, najczęściej używane funkcje, jak w Pythonie wygląda OOP, co to te generatory, iteratory, list/dict comprehensions, f-strings, odczyt, zapis do plików, otwieranie jakiegoś linka za pomocą pythona, co to GIL i wielowątkowość w pythonie, datetime.

Jak? Po prostu wykorzystując w praktyce – zrób kilka różnorodnych projektów, czytaj kod innych osób, zobacz, jak ktoś rozwiązuje dany problem, porównaj ze swoim pomysłem.

Poza tym miałem styczność z takimi bibliotekami w pythonie jak BeatifulSoup, Selenium.

Do tego jest jeszcze C – ale tylko podstawy, które ogarnąłem na CS50. To tylko w ramach nauki o tym, jak pewne rzeczy wyglądają poziom niżej.

Oprócz tego znam html5/css3 na poziomie pozwalającym mi samodzielnie tworzyć proste szablony/modyfikować te bardziej złożone.

JavaScript – tutaj w sumie to wszystko sobie wygoogluje, ale fajnie jak kiedyś dla testu zrobisz sobie, nie wiem, skrypt zmieniający zawartość diva na stronie, albo coś, żeby zobaczyć jak to działa. Pamiętaj też o tym, że często wystarczy sam JS, nie trzeba pierdyliarda bibliotek.

Przy jQuery to samo co JavaScript – niedużo ogarniam, wszystko sobie googluje w miarę potrzeb. Grunt to umieć zaincludować do htmla samego jquery, reszta google.

# Frameworki
To trochę o tym, z jakimi miałem styczność.

Django, flask, dawno dawno temu web2py, wordpress.
Czy w każdym z nich jestem mistrzem? Absolutnie – w żadnym, ale jak wezmę dokumentacje, to coś już tam samodzielnie stworze, przynajmniej w tych dwóch pierwszych.

# Wzorce projektowe
W sumie to pewnie ich używasz, ale nawet o tym nie wiesz i to normalne. Chodzi o to, żebyś kojarzył, iż coś takiego istnieje. Moja wiedza mniej więcej się do tego ogranicza.

# Testowanie
No jest coś takiego. Jak to wygląda? Chodzi o przeklikanie appki? No nie zawsze. Fajnie jest wiedzieć, co to są te testy jednostkowe, testy funkcjonalne i takie tam. Czy musisz być w nich biegły i umieć je pisać? Nie, w zasadzie to większość programistów niezbyt je ogarnia tak w sumie.

# Systemy operacyjne
Jak słyszałeś, że jest coś takiego jak Linux, to spoko. Jak nie, no to też nie najgorzej.
Szczerze to mocno zależne od twojej pracy, czy będzie ci potrzebne, ale moim zdaniem dobrze jest wiedzieć na początku chociaż jakieś podstawy. Nie każę ci tu instalować od razu Gentoo czy coś, ale jak będziesz umiał poruszać się po systemie za pomocą konsoli, utworzyć, przenieść czy zmienić nazwę pliku, usunąć go, za pomocą linuxowej(albo windowsowej) konsoli, to będzie świetnie.

Jeśli o mnie chodzi, to po prostu korzystałem na co dzień z Linuxa, ale nie jest to konieczne. Z czego konkretnie? Manjaro (głównie), Solus, Ubuntu. Do tego drugiego stworzyłem nawet paczkę z pycharmem-community edition bo w repo nie było z racji, że to nowy projekt. Czy ty też musisz? No nie. Tak jak wyżej napisałem, wystarczy umieć się poruszać, bo nuż widelec przyjdzie ci coś zrobić za pomocą SSH, chociażby na VPSie i co? Lipa. A tak to cyk i umiesz.

Chociaż teraz na przykład w ogóle nie korzystam z linuxa, bo pracuję na windowsie – tak akurat się w pracy złożyło. Tak tylko mówię, żeby raz jeszcze zaznaczyć, że znajomość linuxa nie jest konieczna.

Ale załóżmy, że jesteś ambitny. Co w takim razie?
Polecenia: cd, ls, touch, mv, cp, ps, kill, rm, man, echo, grep*, cat
Do tego jak instalować pakiety w danym distro, jak aktualizować.

To wszystko.

# Jak już o systemach mowa
To porozmawiajmy o rzeczach nieco niżej poziomowych. Tak, te okropne, archaiczne rzeczy. Yup. Otóż wyobraźcie sobie, że moje zrozumienie informatyki, programowania i ogólne pojęcie, wzrosło zasadniczo po tym, jak trochę ogarnąłem te właśnie podstawy.

To, jak komputer reprezentuje wszystko w pamięci, jak ta pamięć wygląda, stos i sterta, różnice między nimi, kiedy które używamy.
Struktury danych jak wyglądają, czemu arraye indeksujemy od 0 a nie 1, jak wygląda ta linked list od środka, liczenie w binarnym systemie, hexowym.

Co to ten assembler, jak wygląda proces kompilacji, jaka różnica jest między językami kompilowanymi a interpretowanymi, typowanie statycznie a dynamicznie.

Brzmi nudno, ale te podstawy pozwolą wam stać się po prostu lepszymi programistami. Można tego nie umieć i też znaleźć pracę, ale pytanie. Chcemy być szeroko pojętymi specjalistami czy też może po prostu klepaczami kodu od templatek?

Mi ta wiedza, o tym jak to działa od strony niskopoziomowej, przydała się na rekrutacji do obecnej pracy akurat.

Warto też wiedzieć, jak pewne rzeczy zrobić w konsoli – poza IDE. Lepiej wtedy poznajesz mechanizmy działania niektórych narzędzi.

# Debugging
Jak coś idzie nie tak, to trzeba to naprawić.

Zaprzyjaźnij się chociaż minimalnie z debuggerem, zapoznaj z metodami debugowania.

Bo poza debuggerem można jeszcze robić kapkę inaczej – metody gumowej kaczki, czy też metoda ‘xd’. Fajna sprawa. Na czym one polegają?

Ta pierwsza na tym, że tłumaczysz komuś, czemuś, w domyśle gumowej kaczuszce, jak twój program ma działać krok po kroku. W pewnym momencie może zaskoczyć ci, że AHA! Przecież inaczej to napisałem albo porównujesz to też z kodem i patrzysz czy faktycznie tak jest.

A metoda ‘xd’? To nic innego jak zwykła metoda wypisywania – dodajesz do kodu linie prinutjące pewne dane, jakąś wiadomość charakterystyczną, żeby łatwo odnaleźć w logach i potem patrzysz, gdzie się sypie. U mnie to zazwyczaj ta charakterystyczna wiadomość to ‘XD’ bo jestem zwolennikiem tej filozofii, ale nieważne.

Czyli tak. Ogarniamy debugger.

# Dobre praktyki
Chodzi tu głównie o organizacje kodu, nazywanie zmiennych i tak dalej.
Zmienne powinny być nazywane zwięźle, ale dokładnie, opisowo, konkretnie. Co robi zmienna x? No tego nie wie nikt, ty też zapomnisz, ale jeśli zmienna nazywa się number_of_clients to już coś nam to mówi.

Co do nazw mówimy, to mamy różne metodologie nazywania zmienny, metod, klas.
Camel case, uderscore i tak dalej. Jaka? Bez znaczenia, byleś trzymał się jednej konsekwentnie. Poczytaj PEP8 jeśli jesteś Pythonowcem.

Funkcje, które piszesz nie powinny być też zbyt długie – nie upychaj wszystkiego do jednego wora. Dziel problemy na mniejsze elementy, rozbijaj je i programuj, twórz w sposób pozwalający na ich wielokrotne wykorzystanie bez powtarzania kodu.

Myśl o przypadkach, kiedy user niekoniecznie zachowa się jak oczekujesz. W ogóle zanim zabierzesz się za programowanie to pomyśl. W sumie programowanie to główni e myślenie a dopiero potem pisanie. Przeanalizuj problem, rozważ różne przypadki i dopiero bierz się za implementacje. Pójdzie ci szybciej i stworzysz lepszy kod niż gdybyś bez rozmysłu wziął się po prostu za pisanie.

Dbaj o czytelność kodu, nazw plików.

# VCS
Co to VCS i po co ci to nie będę się zagłębiał, ale jedno jest oczywiste.

Potrzebujesz znać Git’a. A jak nie znasz? Możesz się gdzieś tam dostać, ale to raczej do takiej firmy, z której trzeba uciekać. To nie jest trudne, naucz się. Git commit, merge, branch, checkout, push, pull, rebase. Chyba więcej na początek nie trzeba, mi to starcza.

# Projekty
We flasku zrobiłem dwa, powiedzmy, normalne projekty – jeden nieco bardziej rozbudowany blog (dodawanie wpisów, edycja, komentarze, upvoty, tagi, wyszukiwanie i tak dalej) i prostą emulację najprostszego blockchaina w historii i to w sumie niepełny.

W Django też ze dwa, ale kapkę większe – czytnik mang, dziennik szkolny.
Czyli generalnie po prostu CRUDE’y.

Do tego skrypt w js+python – lubię wiersze Asnyka, więc pythonem sobie zescrapowałem jego zbiór dzieł z neta za pomocą beautifulsoupa, wrzuciłem do .txt w odpowiednim formacie (CSV), a następnie JS’em generowałem z tego losowe wiersze, wystawiając na świat htmlem.

Oprócz tego zrobiłem kiedyś jeszcze prosty układ współrzędnych – wklepujesz jakiś wzór, a skrypt ci rysuje w przeglądarce, funkcjami typu translacja wykresu, odbicie, symetria itd.

Co jeszcze…

Trzy strony na zlecenia – banał. Pobierałem jakiś szablon mniejsza lub większa edycja i cyk, gotowe, czyli klasyczny landing page.

Jedna to typowy lp.

Druga podobnie, ale z integracją galerii z flickera.

Trzecia zaś już kapkę inna – landing page, galeria + jeszcze statycznie generowany jekyllem blog dedykowany dla tej strony.

No i w sumie to jeszcze mój prosty blog, ale to domyślny szablon jekylla lekko zmodyfikowany, więc nie ma o czym pisać, ważny jest jednak fakt, że coś tam miałem napisane – jakieś proste arty, ale zaraz opiszę.

Całość osadziłem na gh-pages w ramach oszczędności na hostingu :D Swoją drogą to dość wygodny sposób do hostowania landing pagów.

Oprócz tego to kiedyś robiłem tam jakieś dwie czy trzy stronki na Wordpressie, ale kiedy to było, nawet nic nie pamiętam, więc do cv nie wpisywałem. Serwerem też się zajmowałem, bo sam hostowałem swoją appkę na vps’ie, czy ustawiałem serwery do CS’a za lat podstawówkowych.

# Blog
Mój zbyt bogaty nie był, ale był. Parę artykułów tam jest. To chyba taki plusik, bo pokazuje, że w sumie to jednak coś tam się tym zajmuje, interesuje i tak dalej.

Co konkretnie na nim było? 6 krótkich artów na tematy techniczne/powiązane i do tego kilka mniej związanych z programowaniem.

A i taki protip: czytaj jakieś blogi/fora branżowe, nowinki, co się w świecie dzieje. Trzeba być cały czas na świeżo z wiadomościami, bo jak nie to wypadniesz z obiegu. Tu w ciągu roku zmienia się tyle, że głowa mała.

# GitHub
Koniecznie załóż, i powrzucaj jakieś projekty. Bardzo duży plus jak nie masz doświadczenia komercyjnego i nie wiesz co wpisać w CV - po prostu wypełnij je jakimiś projektami i tyle ;)

# Jak wyglądało moje CV
O tym w kolejnym wpisie.

# Podsumowanie
Wyżej zawarłem informacje podsumowujące to, co umiałem, gdy szedłem na rozmowę. Większość z tego możecie nauczyć się dzięki CS50 (C, Python, Linux, algo/struktury i tak dalej) na edexie – szczerze polecam każdemu początkującemu. A co potem? Projekty, projekty i projekty.

Oczywiście notka: powyższy tekst jest pełen uproszczeń doprawdy znacznych, ale co zrobić. O części rzeczy pewnie też zapomniałem, ale trudno. Nie uważam się za żaden autorytet, dlatego też we wpisie wielokrotnie powtarzam, że to tylko moja opinia i opis stanu mojej wiedzy jak szedłem na pierwszą rekrutacje, a nie żaden absolut czy wyznacznik, zatem traktujcie wszystko to, co tu napisane, z pewną dozą dystansu. Sam pracuje od grudnia dopiero a to, co wyżej to jedynie relacja moich umiejętności, jakie posiadałem idąc na rozmowę.

Na dziś to chyba wszystko, dzięki za uwagę.